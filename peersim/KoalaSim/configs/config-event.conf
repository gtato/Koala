# network size
SIZE 16 #8192
NR_DC 16 #8192
NR_NODE_PER_DC 3 

#koala stuff
NEIGHBORS 2
LONG_LINKS 3

#chord stuff
M 4
SUCC_SIZE 2


CYCLES 200
CYCLE SIZE*10000


MINDELAY 0
MAXDELAY 0
# drop is a probability, 0<=DROP<=1
DROP 0

msg.categories 3

logging.msg 0 # 1:only send, 2: only receive, 3: both
logging.nodes 0

koala.settings.piggyback 50
koala.settings.dijkstramethod ram #ram, db, spaas
koala.settings.world_size 5  


random.seed 1234567890
#random.seed  203030

network.size SIZE

simulation.endtime CYCLES #CYCLE*CYCLES
simulation.logtime CYCLE
#simulation.experiments 10

ALPHA 1
range.0 ALPHA;-1,0,0.5,1
#range.1 EXP;1:10

protocol.rnode RenaterNode

protocol.knode KoalaNode
{
	linkable rnode
}

protocol.cnode ChordNode

init.0 RenaterInitializer
{
	protocol knode
	cprotocol cnode
	distance 0.01
}

init.1 WireRenater
{
	protocol rnode
	#strategy closest
	#strategy gradualrandom
	#strategy gradual 
	strategy waxman
	undirected
	#k 4
}

init.2 ChordInitializer
{
	protocol chord
}

init.3 KoalaInitializer
{
	protocol renater
	kprotocol koala
	cprotocol chord
	longlinks false
 	#nr 4
}


protocol.tr UniformRandomTransport
{
	mindelay MINDELAY
	maxdelay MAXDELAY
}


protocol.renater RenaterProtocol
{
	linkable rnode
	transport tr
}

protocol.koala KoalaProtocol
{
	linkable knode
	transport tr
	learn true
}

protocol.chord ChordProtocol
{
	linkable cnode
	transport tr
}

control.maintain ChordMaintainer
{
	protocol chord
	step 35
}

control.dnet KoalaDynamicNetwork
{
	add -1
	minsize 50 # in %
	step 5
}

control.planner KoalaPlanner
{
	protocol renater
	kprotocol koala
	cprotocol chord
	step 1	
}

control.rentop RenaterTopologyObserver
{
	protocol rnode
	FINAL 
	at CYCLES
}

control.kotop KoalaTopologyObserver
{
	protocol knode 
	FINAL 
	at CYCLES
}

control.koi KoalaNodeObserver
{
	protocol knode 
	FINAL
	#step (CYCLES/200)
	step (CYCLES/20)
}


control.collector ResultCollector
{
	protocol renater
	kprotocol koala
	cprotocol chord
	FINAL
	step 1 
}




