# network size
NR_DC 1000 #8192
NR_NODE_PER_DC 100 #1000 <--- marin thinks i should try this

SIZE NR_DC*NR_NODE_PER_DC #8192

#koala stuff
#NEIGHBORS 2
#LONG_LINKS 3
#CC 2


#chord stuff
#M 7
SUCC_SIZE 3

CHURN 1
CHURN_STEP 80 

CYCLES 1000000 #2000000
CYCLE SIZE*10000


MINDELAY 0
MAXDELAY 0
# drop is a probability, 0<=DROP<=1
DROP 0

msg.categories 3

logging.msg 0 # 1:only send, 2: only receive, 3: both
logging.nodes 0
logging.file false 


koala.settings.locality unifrom # uniform | "l c g" 
koala.settings.close_latency_rate 0.25
koala.settings.piggyback 50
koala.settings.dijkstramethod ram #ram, db, spaas, hipster
koala.settings.neighbors 2
koala.settings.c 2 #nr_long_links = c*log(n)
koala.settings.responsible_for_c 1 #same as c but for the section for which a node is responsible for 
koala.settings.collaborate false
koala.settings.collaborate_nr 2
koala.settings.collaborate_threshold 20 #help threshold: ask for help if the local best entry gives lower than HELP% of the absolute best entry


#koala.settings.world_size 1  

koala.settings.nested true

# random.seed 1234567890
random.seed  55555

network.size SIZE

simulation.endtime CYCLES #CYCLE*CYCLES
simulation.logtime CYCLE
#simulation.experiments 10

ALPHA 0.5
range.0 ALPHA;-1,0,0.5,1
#range.1 EXP;1:10

protocol.rnode RenaterNode
protocol.knode KoalaNode
protocol.fknode KoalaNode
protocol.lknode KoalaNode
# protocol.cnode ChordNode

init.0 IDInitializer
{	
	rid rnode
	kid knode
	fkid fknode
	lkid lknode
	cid cnode
	
	rpid renater
	kpid koala
	fkpid fkoala
	lkpid lkoala
	cpid chord
	
	trid tr
}



init.1 RenaterInitializer
{
	distance 0.01
	rand false
}

init.2 WireRenater
{
	#protocol rnode
	strategy waxman #closest gradualrandom gradual waxman
	undirected
	#k 4
}

# init.3 ChordInitializer

init.4 KoalaInitializer
{
	initialize false # assigns immediately neighbors and long links (like chord does)
	fromfile true # save or load from a file saved before
	flushload 50000
#    	nr 5000
#     nr 0
}


protocol.tr UniformRandomTransport
{
	mindelay MINDELAY
	maxdelay MAXDELAY
}


protocol.renater RenaterProtocol
{
	skip true
}

protocol.koala KoalaProtocol
protocol.fkoala FlatKoalaProtocol
protocol.lkoala LeaderKoalaProtocol

# protocol.chord ChordProtocol

# control.maintain ChordMaintainer
# {
# 	protocol chord
# 	step 100
# }

# control.dnet KoalaDynamicNetwork
# {
# 	rem CHURN
# # 	minsize 25 # in %
# # 	mode rand
# 	step CHURN_STEP
# # 	at 5000
# 	alt true
# # 	init.0 ChordInitializer
# # 	{      
# # 		protocol chord
# # 	}
# 	
# 	init.1 KoalaInitializer
# 	{      
# 		protocol renater
# 		longlinks false
# 	}
# }


# control.dnet2 KoalaDynamicNetwork
# {
# 	add CHURN
# 	minsize 25 # in %
# # 	mode rand
# 	step CHURN_STEP
# 	from CHURN_STEP/2+1
# 	alt true
# # 	at 2000
# # 	init.0 ChordInitializer
# # 	{      
# # 		protocol chord
# # 	}
# 	
# 	init.1 KoalaInitializer
# 	{      
# 		protocol renater
# 		longlinks false
# 	}
# }


# control.dnet3 KoalaDynamicNetwork
# {
# 	add 1
# 	step 1
# 	init.1 KoalaInitializer
# 	{
# 		protocol fkoala
# 	}
# }

control.planner TrafficGenerator
{
	protocol renater
	step 1	
}

# control.rdifference DifferenceFactor
# {
# 	protocol knode 
# # 	step 100
# 	at 8000 
# 	FINAL	
# }


# control.rentop RenaterTopologyObserver
# {
# 	protocol rnode
# 	FINAL 
# 	at CYCLES
# }
# 
# control.kotop KoalaTopologyObserver
# {
#  	protocol renater 
# 	FINAL 
# 	at CYCLES
# }
 
# control.koi KoalaNodeObserver
# {
# 	protocol knode 
# 	FINAL
# 	#step (CYCLES/200)
# 	step (CYCLES/20)
# }


control.qollector ResultCollector
{
	protocol renater
# 	FINAL
	step 1 
	flush 1000
	filter local close global # specify what should be reported; any combination of local close and global
}

control.terminator Terminate
{
	FINAL
	at CYCLES
}



