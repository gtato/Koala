# network size
SIZE 8 #8192
NR_DC 8 #8192
NR_NODE_PER_DC 3 

#koala stuff
NEIGHBORS 3

#chord stuff
M 10
SUCC_SIZE 4


CYCLES 1000
CYCLE SIZE*10000


MINDELAY 0
MAXDELAY 0
# drop is a probability, 0<=DROP<=1
DROP 0

msg.categories 3

logging.msg 0 # 1:only send, 2: only receive, 3: both
logging.nodes 0

koala.settings.piggyback 50
koala.settings.dijkstramethod ram #ram, db, spaas
koala.settings.world_size 5  


random.seed 1234567890
#random.seed  203030

network.size SIZE

simulation.endtime CYCLES #CYCLE*CYCLES
simulation.logtime CYCLE
#simulation.experiments 10

ALPHA 1
range.0 ALPHA;-1,0,0.5,1
#range.1 EXP;1:10

protocol.rnode RenaterNode

protocol.knode KoalaNode
{
 linkable rnode
}

protocol.cnode ChordNode

init.0 RenaterInitializer
{
 protocol knode
 cprotocol cnode
 distance 0.01
}

init.1 WireRenater
{
 protocol rnode
#strategy closest
#strategy gradualrandom
#strategy gradual 
strategy waxman
 undirected
#k 4
}

init.2 ChordInitializer
{
 protocol chord
}

init.3 KoalaInitializer
{
 protocol renater
 kprotocol koala
 cprotocol chord
longlinks false
nr_longlinks 3
 #nr 4
}


control.dnet KoalaDynamicNetwork
{
	add 0
	minsize 80 # in %
	step 200
}


protocol.tr UniformRandomTransport
{
 mindelay MINDELAY
 maxdelay MAXDELAY
}


protocol.renater RenaterProtocol
{
 linkable rnode
 transport tr
}

protocol.koala KoalaProtocol
{
 linkable knode
 transport tr
learn true
}

protocol.chord ChordProtocol
{
 linkable cnode
 transport tr
}

control.maintain ChordMaintainer
{
	step 500
	protocol chord
}


control.planner KoalaPlanner
{
 protocol renater
 kprotocol koala
 cprotocol chord
 step 1	
}

control.rentop RenaterTopologyObserver
{
 protocol rnode
 FINAL 
 at CYCLES
}

control.kotop KoalaTopologyObserver
{
 protocol knode 
 FINAL 
 at CYCLES
}

control.koi KoalaNodeObserver
{
 protocol knode 
 FINAL
#step (CYCLES/200)
step (CYCLES/20)
}


control.collector ResultCollector
{
 protocol renater
 kprotocol koala
 cprotocol chord
 FINAL
 step 1 
}




